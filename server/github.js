const express = require('express')
const multer = require('multer')
const url = require('url')
const _ = require('lodash')
const stem = require('stem-porter')
const asana = require('./util/asana')
const logger = require('./util/logger')

const ASANA_LINK_PREFIX = 'https://app.asana'

module.exports = function () {
  const router = express.Router()
  const m = multer({})

  router.post('/push', m.any(), (req, res) => {
    try {
      if (req.body) {
        logger.capture('Push', req.body)
        const commits = req.body.commits || []

        commits.forEach(commit => {
          const who = _.get(commit, 'sender.login', '<unknown>')

          parseAndCommentOnAsana(
            commit.message,
            `(Auto Generated by ${who}) Pushed commit:\n` + commit.url)
        })
      }
    } catch (error) {
      logger.error(error)
    }

    res.sendStatus(200)
  })

  router.post('/pr', m.any(), (req, res) => {
    try {
      if (req.body) {
        logger.capture('Pull Request', req.body)

        switch (req.body.action) {
          case 'closed':
            const pr = req.body.pull_request

            // only procecess the merged PRs
            if (pr && pr.body && pr.merged) {
              const who = _.get(pr, 'sender.login', '<unknown>')

              parseAndCommentOnAsana(
                pr.body,
                `(Auto Generated by ${who}) Merged PR:\n` + pr.html_url)
            }
            break

          default:
            logger.info(`${req.body.action} is not supported yet.`)
            break
        }
      }
    } catch (error) {
      logger.error(error)
    }

    res.sendStatus(200)
  })

  return router
}

/**
 * @param message - the message that we want to parse
 *        (this can be from a PR, commit, etc)
 * @asanaMessage - the message that we want to post to
 *        asana when parsing this comment.
 */
function parseAndCommentOnAsana (message, asanaMessage) {
  // parse the lines that contain Asana info
  const splitted = message.split('\n')
  const asanaLines = splitted
    .filter(line => line.includes(ASANA_LINK_PREFIX))

  // capture this, in case we need to look at it later
  logger.capture('Asana tickets to process', asanaLines)

  // each asana line is a sentence that contains the asana link
  // example: 'I am closing <asana link>'
  asanaLines.forEach(asanaLine => {
    const wordsOnLine = asanaLine.split(' ')

    wordsOnLine.forEach((word, idx) => {
      // the word we're looking at is an asana link
      if (word.startsWith(ASANA_LINK_PREFIX)) {
        // parse the link and add the comment
        const asanaPath = url.parse(word).path

        // example: [ '', '0', '248400113261909', '463141492036657' ]
        const asanaSegments = asanaPath.split('/')

        if (asanaSegments.length === 4) {
          const taskId = asanaSegments[3]

          asana.stories.createOnTask(taskId, {
            text: asanaMessage
          }).then(res => {
            logger.info('Asana comment posted', Object.assign({}, res, {
              asanaMessage
            }))
          }).catch(err => {
            logger.error(err)
          })

          // if there is a word before this, and
          // if the word before this has a porter stem of `close` or `complet`
          // then complete the asana task too.
          if (idx > 0) {
            const wordBefore = wordsOnLine[idx - 1]
              .replace(/[^A-Za-z]/gi, '')
              .toLowerCase()

            if (stem(wordBefore) === 'close' || stem(wordBefore) === 'complet') {
              asana.tasks.update(taskId, {
                completed: true
              }).then(res => {
                logger.info('Asana task completed', res)
              }).catch(err => {
                logger.error(err)
              })
            }
          }
        }
      }
    })
  })
}
